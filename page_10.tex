\subsubsection{Semantica de \(\mathcal{S}^{\Sigma }\)}


Definamos

\(\displaystyle \begin{array}{rcl} \omega ^{\left[ \mathbf{N}\right] } & =& \left\{ (s_{1},s_{2},...)\in \omega ^{ \mathbf{N}}:\text{ hay }n\in \mathbf{N}\text{ tal que }s_{i}=0,\text{para } i\geq n\right\} \\ \Sigma ^{\ast \left[ \mathbf{N}\right] } & =& \left\{ (\sigma _{1},\sigma _{2},...)\in \Sigma ^{\ast \mathbf{N}}:\text{ hay }n\in \mathbf{N}\text{ tal que }\sigma _{i}=\varepsilon ,\text{para }i\geq n\right\} . \end{array} \)

Asumiremos siempre que en una computacion via un programa de \(\mathcal{S} ^{\Sigma }\), todas exepto una cantidad finita de las variables numericas tienen el valor \(0\) y todas exepto una cantiad finita de las variables alfabeticas tienen el valor \(\varepsilon \). Esto no quita generalidad a nuestra modelizacion del funcionamiento de los programas ya que todo programa envuelve una cantidad finita de variables. O sea que, en general, independientemente de que programa estemos considerando, un estado sera un par
\(\displaystyle (\vec{s},\vec{\sigma})=((s_{1},s_{2},...),(\sigma _{1},\sigma _{2},...))\in \omega ^{\left[ \mathbf{N}\right] }\times \Sigma ^{\ast \left[ \mathbf{N} \right] }. \)

Si \(i\geq 1\), entonces diremos que \(s_{i}\) es el contenido de la variable \(\mathrm{N}\bar{\imath}\) en el estado \((\vec{s},\vec{\sigma})\) y \( \sigma _{i}\) es el contenido de la variable \(\mathrm{P}\bar{\imath}\) en el estado \((\vec{s},\vec{\sigma})\).
Una descripcion instantanea es una terna \((i,\vec{s},\vec{\sigma})\) tal que \((\vec{s},\vec{\sigma})\) es un estado e \(i\in \omega \). Dado un programa \(\mathcal{P}\) y una descripcion instantanea \((i,\vec{s},\vec{\sigma} )\) definamos la descripcion instantanea sucesora de \((i,\vec{s}, \vec{\sigma})\) como la terna \((j,\vec{u},\vec{\eta})\) descripta a continuacion en los siguientes casos

Caso \(i\notin \{1,...,n(\mathcal{P})\}.\) Entonces \((j,\vec{u},\vec{\eta})=(i, \vec{s},\vec{\sigma})\) (ya que en \((i,\vec{s},\vec{\sigma})\) el numero \(i\) indica que la instruccion \(I_{i}^{\mathcal{P}}\) debe ser ejecutada, es natural definir \((j,\vec{u},\vec{\eta})=(i,\vec{s},\vec{\sigma})\) ya que, en este caso, no se puede ejecutar la instruccion \(I_{i}^{\mathcal{P} }=\varepsilon \)).

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k} \dot{-}1.\) Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& (s_{1},...,s_{k-1},s_{k}\dot{-}1,s_{k+1},...) \\ \vec{\eta} & =& \vec{\sigma} \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k} +1.\) Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& (s_{1},...,s_{k-1},s_{k}+1,s_{k+1},...) \\ \vec{\eta} & =& \vec{\sigma} \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}\) . Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& (s_{1},...,s_{k-1},s_{n},s_{k+1},...) \\ \vec{\eta} & =& \vec{\sigma} \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{N}\bar{k}\leftarrow 0.\) Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& (s_{1},...,s_{k-1},0,s_{k+1},...) \\ \vec{\eta} & =& \vec{\sigma} \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\) \(\mathrm{N}\bar{k}\) \(\neq 0\) \( \mathrm{GOTO}\) \(\mathrm{L}\bar{m}.\) Entonces

\(\displaystyle \begin{array}{rcl} \vec{u} & =& \vec{s} \\ \vec{\eta} & =& \vec{\sigma} \end{array} \)

y tenemos dos subcasos.
Subcaso a. El valor de \(\mathrm{N}\bar{k}\) en \((\vec{s},\vec{\sigma})\) es 0. Entonces \(j=i+1.\)

Subcaso b. El valor de \(\mathrm{N}\bar{k}\) en \((\vec{s},\vec{\sigma})\) es no nulo. Entonces \(j\) es el menor numero \(l\) tal que la \(l\)-esima instruccion de \(\mathcal{P}\) tiene label \(\mathrm{L}\bar{m}\).

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \) \( ^{\curvearrowright }\mathrm{P}\bar{k}.\) Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& \vec{s} \\ \vec{\eta} & =& (\sigma _{1},...,\sigma _{k-1},^{\curvearrowright }\sigma _{k},\sigma _{k+1},...) \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k} .a\). Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& \vec{s} \\ \vec{\eta} & =& (\sigma _{1},...,\sigma _{k-1},\sigma _{k}a,\sigma _{k+1},...) \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{n}\) . Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& \vec{s} \\ \vec{\eta} & =& (\sigma _{1},...,\sigma _{k-1},\sigma _{n},\sigma _{k+1},...) \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{P}\bar{k}\leftarrow \varepsilon .\) Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& \vec{s} \\ \vec{\eta} & =& (\sigma _{1},...,\sigma _{k-1},\varepsilon ,\sigma _{k+1},...) \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS }\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{m}.\) Entonces

\(\displaystyle \begin{array}{rcl} \vec{u} & =& \vec{s} \\ \vec{\eta} & =& \vec{\sigma} \end{array} \)

y tenemos dos subcasos.
Subcaso a. El valor de \(\mathrm{P}\bar{k}\) en \((\vec{s},\vec{\sigma})\) comiensa con \(a\). Entonces \(j\) es el menor numero \(l\) tal que la \(l\)-esima instruccion de \(\mathcal{P}\) tiene label \(\mathrm{L}\bar{m}.\)

Subcaso b. El valor de \(\mathrm{P}\bar{k}\) en \((\vec{s},\vec{\sigma})\) no comiensa con \(a\). Entonces \(j=i+1\)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{GOTO}\;\mathrm{L}\bar{m}\). Entonces

\(\displaystyle \begin{array}{rcl} j & =& \text{ menor numero }l\text{ tal que la }l\text{-esima instruccion de } \mathcal{P}\text{ tiene label }\mathrm{L}\bar{m}. \\ \vec{u} & =& \vec{u} \\ \vec{\eta} & =& \vec{\eta} \end{array} \)

Caso \(Bas(I_{i}^{\mathcal{P}})=\mathrm{SKIP}\). Entonces

\(\displaystyle \begin{array}{rcl} j & =& i+1 \\ \vec{u} & =& \vec{u} \\ \vec{\eta} & =& \vec{\eta} \end{array} \)

Dado un programa \(\mathcal{P}\) y una descripcion instantanea \((i,\vec{s}, \vec{\sigma})\) usaremos \(DIS_{\mathcal{P}}(i,\vec{s},\vec{\sigma})\) para denotar la descripcion instantanea sucesora de \((i,\vec{s},\vec{\sigma})\) en \(\mathcal{P}\). Dado un programa \(\mathcal{P}\) y un estado \((\vec{s},\vec{ \sigma})\) tenemos asociada una sucesion infinita de descripciones instantaneas

\(\displaystyle (i_{1},\vec{s}_{1},\vec{\sigma}_{1}),(i_{2},\vec{s}_{2},\vec{\sigma} _{2}),(i_{3},\vec{s}_{3},\vec{\sigma}_{3}),... \)

definida de la siguiente manera
\(\displaystyle \begin{array}{rcl} (i_{1},\vec{s}_{1},\vec{\sigma}_{1}) & =& (1,\vec{s},\vec{\sigma}) \\ (i_{j+1},\vec{s}_{j+1},\vec{\sigma}_{j+1}) & =& DIS_{\mathcal{P}}(i_{j},\vec{s} _{j},\vec{\sigma}_{j}) \end{array} \)

Diremos que \((\vec{s}_{j+1},\vec{\sigma}_{j+1})\) es el estado obtenido luego de \(j\) pasos, partiendo del estado \((\vec{s},\vec{ \sigma})\). Tambien diremos que \((i_{j+1},\vec{s}_{j+1},\vec{\sigma}_{j+1})\) es la descripcion instantanea obtenida luego de \(j\) pasos, partiendo de la descripcion instantanea \((1,\vec{s},\vec{\sigma})\). La sucesion anterior tiene dos posibles formas
Caso 1. Hay un \(m\geq 1\) tal que \(i_{1},...,i_{m}\leq n(\mathcal{P} ) \) y \(i_{m+k}=n(\mathcal{P})+1\), para cada \(k\geq 1.\)
Caso 2. Para cada \(j\geq 1\), tenemos que \(i_{j}\leq n(\mathcal{P}).\)
Cuando se da el Caso 1, diremos para cada \(j\geq m\) que \(\mathcal{P }\) se detiene (luego de \(j\) pasos), partiendo desde el estado \((\vec{s},\vec{\sigma})\). Si se da el Caso 2 diremos que \(\mathcal{P} \) no se detiene partiendo del estado \((\vec{s},\vec{\sigma})\).




\subsubsection{Macros}

Usaremos como variables numericas de macros a las palabras de la forma \( \mathrm{V}\bar{m}\), con \(m\geq 1.\) Usaremos como variables alfabeticas de macros a las palabras de la forma \(\mathrm{W}\bar{m}\), con \(m\geq 1.\) Usaremos como variables para labels de macros a las palabras de la forma \( \mathrm{A}\bar{m}\), con \(m\geq 1\). Si \(\Sigma =\{@,!,\& \}\) entonces el macro \(\left[ \mathrm{IF\ W}1\neq \varepsilon \;\mathrm{GOTO}\;\mathrm{A}1\right] \) puede ser hecho de la siguiente manera

\(\displaystyle \begin{array}{l} \mathrm{IF}\;\mathrm{W}1\;\mathrm{BEGINS}\;@\;\mathrm{GOTO}\;\mathrm{A}1 \\ \mathrm{IF}\;\mathrm{W}1\;\mathrm{BEGINS}\;!\;\mathrm{GOTO}\;\mathrm{A}1 \\ \mathrm{IF}\;\mathrm{W}1\;\mathrm{BEGINS}\;\& \;\mathrm{GOTO}\;\mathrm{A}1 \end{array} \)

Para hacer el macro \(\left[ \mathrm{V}1\leftarrow \mathrm{V}2+\mathrm{V}3 \right] \) podriamos tomar
\(\displaystyle \begin{array}{ll} & \mathrm{V}1\leftarrow \mathrm{V}2 \\ & \mathrm{V}4\leftarrow \mathrm{V}3 \\ \mathrm{A}1 & \mathrm{IF}\;\mathrm{V}4\neq 0\;\mathrm{GOTO}\;\mathrm{A}2 \\ & \mathrm{GOTO}\;\mathrm{A}3 \\ \mathrm{A}2 & \mathrm{V}4\leftarrow \mathrm{V}4-1 \\ & \mathrm{V}1\leftarrow \mathrm{V}1+1 \\ & \mathrm{GOTO}\;\mathrm{A}1 \\ \mathrm{A}3 & \mathrm{SKIP} \end{array} \)



\subsubsection{Funciones \(\Sigma \)-computables}

Dado \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\), definamos para cada par \( n,m\geq 0\), la funcion \(\Psi _{\mathcal{P}}^{n,m,\omega }\) de la siguiente manera:

\(\displaystyle \begin{array}{l} D_{\Psi _{\mathcal{P}}^{n,m,\omega }}=\{(\vec{x},\vec{\alpha})\in \omega ^{n}\times \Sigma ^{\ast m}:\mathcal{P}\text{ termina, partiendo del} \\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; \text{estado }((x_{1},...,x_{n},0,...),(\alpha _{1},...,\alpha _{m},\varepsilon ,...))\} \end{array} \)

\(\displaystyle \begin{array}{l} \Psi _{\mathcal{P}}^{n,m,\omega }(\vec{x},\vec{\alpha})=\text{valor de } \mathrm{N}1\text{ en el estado obtenido cuando }\mathcal{P}\text{ termina,} \\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{partiendo de } ((x_{1},...,x_{n},0,...),(\alpha _{1},...,\alpha _{m},\varepsilon ,...)) \end{array} \)

Analogamente definamos la funcion \(\Psi _{\mathcal{P}}^{n,m,\Sigma ^{\ast }}\) de la siguiente manera:
\(\displaystyle \begin{array}{l} D_{\Psi _{\mathcal{P}}^{n,m,\Sigma ^{\ast }}}=\{(\vec{x},\vec{\alpha})\in \omega ^{n}\times \Sigma ^{\ast m}:\mathcal{P}\text{ termina, partiendo del} \\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; \text{estado }((x_{1},...,x_{n},0,...),(\alpha _{1},...,\alpha _{m},\varepsilon ,...))\} \end{array} \)

\(\displaystyle \begin{array}{l} \Psi _{\mathcal{P}}^{n,m,\Sigma ^{\ast }}(\vec{x},\vec{\alpha})=\text{valor de }\mathrm{P}1\text{ en el estado obtenido cuando }\mathcal{P}\text{ termina,} \\ \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\text{partiendo de } (x_{1},...,x_{n},0,...),(\alpha _{1},...,\alpha _{m},\varepsilon ,...)) \end{array} \)

Una funcion \(\Sigma \)-mixta \(f:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) sera llamada \(\Sigma \)-computable si hay un programa \( \mathcal{P}\) tal que \(f=\Psi _{\mathcal{P}}^{n,m,O}\). En tal caso diremos que la funcion \(f\) es computada por \(\mathcal{P}\).
Ejemplos: (a) El programa

\(\displaystyle \begin{array}{ll} \mathrm{L}2 & \mathrm{IF}\;\mathrm{N}1\neq 0\;\mathrm{GOTO}\;\mathrm{L}1 \\ & \mathrm{GOTO}\;\mathrm{L}2 \\ \mathrm{L}1 & \mathrm{N}1\leftarrow \mathrm{N}1\dot{-}1 \end{array} \)

computa la funcion \(Pred\). Note que este programa tambien computa las funciones \(Pred\circ p_{1}^{n,m}\), para \(n\geq 1\) y \(m\geq 0.\)
(b) Sea \(\Sigma =\{\clubsuit ,\triangle \}.\) El programa

\(\displaystyle \begin{array}{ll} \mathrm{L}3 & \mathrm{IF}\;\mathrm{P}2\;\mathrm{BEGINS}\;\clubsuit \;\mathrm{ GOTO}\;\mathrm{L}1 \\ & \mathrm{IF}\;\mathrm{P}2\;\mathrm{BEGINS}\;\triangle \;\mathrm{GOTO}\; \mathrm{L}2 \\ & \mathrm{GOTO}\;\mathrm{L}4 \\ \mathrm{L}1 & \mathrm{P}2\leftarrow \text{ }^{\curvearrowright }\mathrm{P}2 \\ & \mathrm{P}1\leftarrow \mathrm{P}1\clubsuit \\ & \mathrm{GOTO}\;\mathrm{L}3 \\ \mathrm{L}2 & \mathrm{P}2\leftarrow \text{ }^{\curvearrowright }\mathrm{P}2 \\ & \mathrm{P}1\leftarrow \mathrm{P}1\triangle \\ & \mathrm{GOTO}\;\mathrm{L}3 \\ \mathrm{L}4 & \mathrm{SKIP} \end{array} \)

computa la funcion \(\lambda \alpha \beta \left[ \alpha \beta \right] .\)



\textbf{Teorema 53} Si \(f\) es \(\Sigma \)-computable, entonces \(f\) es \(\Sigma \)-efectivamente computable.
Prueba: Supongamos por ejemplo que \(f:S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) es computada por \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\). Es claro que el procedimiento que consiste en realizar las sucesivas instrucciones de \(\mathcal{P}\) (partiendo de \(((x_{1},...,x_{n},0,0,...),( \alpha _{1},...,\alpha _{m},\varepsilon ,\varepsilon ,...))\)) y eventualmente terminar en caso de que nos toque realizar la instruccion \(n( \mathcal{P})+1\), y dar como salida el contenido de la variable \(\mathrm{N}1\) , es un procedimiento efectivo que computa a \(f\). \(\Box\)
