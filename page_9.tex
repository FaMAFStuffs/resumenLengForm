\section{El lenguaje \(\mathcal{S}^{\Sigma }\)}

En esta seccion introducimos un lenguaje de programacion teorico el cual depende de un alfabeto \(\Sigma \) previamente fijado. Este lenguaje, llamado \( \mathcal{S}^{\Sigma }\), nos servira para dar una version imperativa del concepto de funcion \(\Sigma \)-efectivamente computable.

\subsection{Sintaxis de \(\mathcal{S}^{\Sigma }\)}

Necesitaremos algunas funciones basicas para poder describir la sintaxis de \( \mathcal{S}^{\Sigma }\) en forma precisa. Llamaremos numerales a los siguientes simbolos

\(\displaystyle 0\ 1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9 \)

Usaremos \(Num\) para denotar el conjunto de numerales. Notese que \(Num\cap \omega =\varnothing \). Sea \(S:Num^{\ast }\rightarrow Num^{\ast }\) definida de la siguiente manera
\(\displaystyle \begin{array}{rcl} S(\varepsilon ) & =& 1 \\ S(\alpha 0) & =& \alpha 1 \\ S(\alpha 1) & =& \alpha 2 \\ S(\alpha 2) & =& \alpha 3 \\ S(\alpha 3) & =& \alpha 4 \\ S(\alpha 4) & =& \alpha 5 \\ S(\alpha 5) & =& \alpha 6 \\ S(\alpha 6) & =& \alpha 7 \\ S(\alpha 7) & =& \alpha 8 \\ S(\alpha 8) & =& \alpha 9 \\ S(\alpha 9) & =& S(\alpha )0 \end{array} \)

Definamos \(\overline{\ \ \ \;}:\omega \rightarrow Num^{\ast }\) de la siguiente manera
\(\displaystyle \begin{array}{rcl} \bar{0} & =& \varepsilon \\ \overline{n+1} & =& S(\bar{n}) \end{array} \)

Notese que para \(n\in \mathbf{N}\), la palabra \(\bar{n}\) es la notacion usual decimal de \(n\). Para \(\alpha \in \Sigma ^{\ast }\), sea
\(\displaystyle ^{\curvearrowright }\alpha =\left\{ \begin{array}{lll} \left[ \alpha \right] _{2}...\left[ \alpha \right] _{\left\vert \alpha \right\vert } & \text{si} & \left\vert \alpha \right\vert \geq 2 \\ \varepsilon & \text{si} & \left\vert \alpha \right\vert \leq 1 \end{array} \right. \)

La sintaxis de \(\mathcal{S}^{\Sigma }\) sera dada utilizando solo simbolos del alfabeto \(\Sigma \cup \Sigma _{p}\), donde
\(\displaystyle \Sigma _{p}=Num\cup \left\{ \leftarrow ,+,\dot{-},.,\neq ,^{\curvearrowright },\varepsilon ,\mathrm{N},\mathrm{K},\mathrm{P},\mathrm{L},\mathrm{I}, \mathrm{F},\mathrm{G},\mathrm{O},\mathrm{T},\mathrm{B},\mathrm{E},\mathrm{S} \right\} . \)

Cabe aclarar que la palabra de longitud \(0\) no es un elemento de \(\Sigma _{p} \) sino que la letra griega \(\varepsilon \) que usualmente denota esta palabra, lo es. Las palabras de la forma \(\mathrm{N}\bar{k}\) con \(k\in \mathbf{N}\), son llamadas variables numericas de \(\mathcal{S} ^{\Sigma }\). Las palabras de la forma \(\mathrm{P}\bar{k}\) con \(k\in \mathbf{N }\), son llamadas variables alfabeticas de \(\mathcal{S}^{\Sigma }\). Las palabras de la forma \(\mathrm{L}\bar{k}\) con \(k\in \mathbf{N}\), son llamadas labels de \(\mathcal{S}^{\Sigma }\). Una instruccion basica de \(\mathcal{S}^{\Sigma }\) es un elemento de \((\Sigma \cup \Sigma _{p})^{\ast }\) el cual es de alguna de las siguientes formas

\(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}+1\)
\(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}\dot{-}1\)
\(\mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n}\)
\(\mathrm{N}\bar{k}\leftarrow 0\)
\(\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k}.a\)
\(\mathrm{P}\bar{k}\leftarrow \) \(^{\curvearrowright }\mathrm{P}\bar{k }\)
\(\mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{n}\)
\(\mathrm{P}\bar{k}\leftarrow \varepsilon \)
\(\mathrm{IF}\;\mathrm{N}\bar{k}\neq 0\;\mathrm{GOTO}\;\mathrm{L} \bar{n}\)
\(\mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\; \mathrm{L}\bar{n}\)
\(\mathrm{GOTO}\;\mathrm{L}\bar{n}\)
\(\mathrm{SKIP}\)
donde \(a\in \Sigma \) y \(k,n\in \mathbf{N}\). Como puede observarse para que las instrucciones basicas sean mas lejibles usaremos espacios entre ciertos simbolos. Por ejemplo, escribiremos

\(\displaystyle \mathrm{L}1\;\mathrm{IF}\;\mathrm{N}5\neq 0\;\mathrm{GOTO}\;\mathrm{L}3 \)

en lugar de
\(\displaystyle \mathrm{L}1\mathrm{IFN}5\mathrm{\neq }0\mathrm{GOTOL}3 \)

pero debe entenderse que la instruccion basica a la que nos referimos es esta ultima palabra de longitud 14.
Una instruccion de \(\mathcal{S}^{\Sigma }\) es una palabra de la forma \(\alpha I\), donde \(\alpha \in \{\mathrm{L}\bar{n}:n\in \mathbf{N} \}\cup \{\varepsilon \}\) y \(I\) es una instruccion basica. Usaremos \(\mathrm{ Ins}^{\Sigma }\) para denotar el conjunto de todas las instrucciones de \( \mathcal{S}^{\Sigma }\). Cuando la instruccion \(I\) es de la forma \(\mathrm{L} \bar{n}J\) con \(J\) una instruccion basica, diremos que \(\mathrm{L}\bar{n}\) es el label de \(I\). Damos a continuacion, a modo de ejemplo, la interpretacion intuitiva asociada a ciertas instrucciones basicas de \( \mathcal{S}^{\Sigma }\):

\(\displaystyle \begin{array}{rcl} \text{INSTRUCCION} & :& \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{k}\dot{-}1 \\ \text{INTERPRETACION} & :& \begin{array}{c} \text{Si el contenido de }\mathrm{N}\bar{k}\text{ es }0\text{ dejarlo sin modificar; en} \\ \text{caso contrario disminuya en 1 el contenido de }\mathrm{N}\bar{k}\; \end{array} \\ \text{INSTRUCCION} & :& \mathrm{N}\bar{k}\leftarrow \mathrm{N}\bar{n} \\ \text{INTERPRETACION} & :& \begin{array}{c} \text{Copiar en }\mathrm{N}\bar{k}\text{ el contenido de }\mathrm{N}\bar{n} \text{ } \\ \text{sin modificar el contenido de }\mathrm{N}\bar{n} \end{array} \\ \text{INSTRUCTION} & :& \mathrm{P}\bar{k}\leftarrow ^{\curvearrowright } \mathrm{P}\bar{k} \\ \text{INTERPRETATION} & :& \begin{array}{l} \text{Si el contenido de }\mathrm{P}\bar{k}\text{ es }\varepsilon \text{ dejarlo sin modificar;} \\ \text{en caso contrario remueva el 1er simbolo del} \\ \text{contenido de }\mathrm{P}\bar{k} \end{array} \end{array} \)

\(\displaystyle \begin{array}{rcl} \text{INSTRUCTION} & :& \mathrm{P}\bar{k}\leftarrow \mathrm{P}\bar{k}.a \\ \text{INTERPRETATION} & :& \begin{array}{l} \text{Modificar el contenido de }\mathrm{P}\bar{k}\text{ agregandole} \\ \text{el simbolo }a\text{ a la derecha} \end{array} \\ \text{INSTRUCTION} & :& \mathrm{IF}\;\mathrm{P}\bar{k}\;\mathrm{BEGINS}\;a\; \mathrm{GOTO}\;\mathrm{L}\bar{m} \\ \text{INTERPRETATION} & :& \begin{array}{l} \text{Si el contenido de }\mathrm{P}\bar{k}\text{ comiensa con }a,\text{ ejecute} \\ \text{la primer instruccion con label }\mathrm{L}\bar{m}\text{; en caso} \\ \text{contrario ejecute la siguiente instruccion} \end{array} \end{array} \)

Un programa de \(\mathcal{S}^{\Sigma }\) es una palabra de la forma

\(\displaystyle I_{1}I_{2}...I_{n} \)

donde \(n\geq 1\), \(I_{1},...,I_{n}\in \mathrm{Ins}^{\Sigma }\) y para cada \( i=1,...,n\), tenemos que
- si \(\mathrm{GOTOL}\bar{m}\) es un tramo final de \(I_{i}\), entonces existe \(j\) tal que \(I_{j}\) tiene label \(\mathrm{L}\bar{m}\)
Usaremos \(\mathrm{Pro}^{\Sigma }\) para denotar el conjunto de todos los programas de \(\mathcal{S}^{\Sigma }\). Como es usual cuando escribamos un programa lo haremos linea por linea, con la finalidad de que sea mas lejible. Por ejemplo, escribiremos

\(\displaystyle \begin{array}{ll} \mathrm{L}2 & \mathrm{N}12\leftarrow \mathrm{N}12\dot{-}1 \\ & \mathrm{P}1\leftarrow \text{ }^{\curvearrowright }\mathrm{P}1 \\ & \mathrm{IF\;N}12\neq 0\;\mathrm{GOTO}\;\mathrm{L}2 \end{array} \)

en lugar de
\(\displaystyle \mathrm{L}2\mathrm{N}12\mathrm{\leftarrow }\text{N}12\mathrm{\dot{-}}1 \mathrm{P}1\mathrm{\leftarrow }^{\curvearrowright }\mathrm{P}1\mathrm{IFN}12 \mathrm{\neq }0\mathrm{GOTOL}2 \)

Un importante resultado es el siguiente lema que garantiza que los programas pueden ser parseados en forma unica como concatenacion de instrucciones.




\textbf{Lema 52} Se tiene que:
(a) Si \(I_{1}...I_{n}=J_{1}...J_{m}\), con \( I_{1},...,I_{n},J_{1},...,J_{m}\in \mathrm{Ins}^{\Sigma }\), entonces \(n=m\) y \(I_{j}=J_{j}\) para cada \(j\geq 1\).
(b) Si \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\), entonces existe una unica sucesion de instrucciones \(I_{1},...,I_{n}\) tal que \(\mathcal{P} =I_{1}...I_{n}\)
Prueba: (a) Supongamos \(I_{n}\) es un tramo final propio de \(J_{m}.\) Notar que entonces \(n >1\). Es facil ver que entonces ya sea \(J_{m}=\mathrm{L}\bar{u} I_{n}\) para algun \(u\in \mathbf{N}\), o \(I_{n}\) es de la forma \(\mathrm{GOTO} \;\mathrm{L}\bar{n}\) y \(J_{m}\) es de la forma \(w\mathrm{IF}\;\mathrm{P}\bar{k }\;\mathrm{BEGINS}\;a\;\mathrm{GOTO}\;\mathrm{L}\bar{n}\) donde \(w\in \{ \mathrm{L}\bar{n}:n\in \mathbf{N}\}\cup \{\varepsilon \}\). El segundo caso no puede darse porque entonces el anteultimo simbolo de \(I_{n-1}\) deberia ser \(\mathrm{S}\) lo cual no sucede para ninguna instruccion. O sea que

\(\displaystyle I_{1}...I_{n}=J_{1}...J_{m-1}\mathrm{L}\bar{u}I_{n} \)

lo cual dice que
(*) \(I_{1}...I_{n-1}=J_{1}...J_{m-1}\mathrm{L}\bar{u}.\)
Es decir que \(\mathrm{L}\bar{u}\) es tramo final de \(I_{n-1}\) y por lo tanto \(\mathrm{GOTO}\;\mathrm{L}\bar{u}\) es tramo final de \(I_{n-1}.\) Por (*), \(\mathrm{GOTO}\) es tramo final de \(J_{1}...J_{m-1}\), lo cual es impossible. Hemos llegado a una contradiccion lo cual nos dice que \(I_{n}\) no es un tramo final propio de \(J_{m}.\) Por simetria tenemos que \( I_{n}=J_{m} \), lo cual usando un razonamiento inductivo nos dice que \(n=m\) y \(I_{j}=J_{j} \) para cada \(j\geq 1\).

(b) Es consecuencia directa de (a). \(\Box\)

(b) del lema anterior nos dice que dado un programa \(\mathcal{P}\), tenemos univocamente determinados \(n(\mathcal{P})\in \mathbf{N}\) y \(I_{1}^{\mathcal{P }},...,I_{n(\mathcal{P})}^{\mathcal{P}}\in \mathrm{Ins}^{\Sigma }\) tales que \(\mathcal{P}=I_{1}^{\mathcal{P}}...I_{n(\mathcal{P})}^{\mathcal{P}}\). Definamos tambien

\(\displaystyle I_{i}^{\mathcal{P}}=\varepsilon \)

cuando \(i=0\) o \(i >n(\mathcal{P})\). O sea que, la funcion \((\Sigma \cup \Sigma _{p})\)-mixta \(\lambda i\mathcal{P}\left[ I_{i}^{\mathcal{P}}\right] \) tiene dominio igual a \(\omega \times \mathrm{Pro}^{\Sigma }\).
Tambien sera necesaria la funcion \(Bas:\mathrm{Ins}^{\Sigma }\rightarrow (\Sigma \cup \Sigma _{p})^{\ast }\), dada por

\(\displaystyle Bas(I)=\left\{ \begin{array}{ccl} J & & \text{si }I\text{ es de la forma }\mathrm{L}\bar{k}J\text{ con }J\in \mathrm{Ins}^{\Sigma } \\ I & & \text{caso contrario} \end{array} \right. \)
