\subsection{Codificacion de sucesiones infinitas de numeros}

Dado \(n\in \mathbf{N}\), usaremos \(pr(n)\) para denotar el \(n\)-esimo numero primo. Notese que \(pr(1)=2\), \(pr(2)=3\), \(pr(3)=5\), etc. Usaremos \(\omega ^{ \mathbf{N}}\) para denotar el conjunto de todas las sucesiones infinitas de elementos de \(\omega .\) Es decir

\(\displaystyle \omega ^{\mathbf{N}}=\left\{ (s_{1},s_{2},...):s_{i}\in \omega \text{, para cada }i\geq 1\right\} \text{.} \)

Definamos el siguiente subconjunto de \(\omega ^{\mathbf{N}}\)
\(\displaystyle \omega ^{\left[ \mathbf{N}\right] }=\left\{ (s_{1},s_{2},...)\in \omega ^{ \mathbf{N}}:\text{ hay un }n\in \mathbf{N}\text{ tal que }s_{i}=0,\text{para }i\geq n\right\} \text{.} \)

Notese que \(\omega ^{\mathbf{N}}\neq \omega ^{\left[ \mathbf{N}\right] }\), por ejemplo las sucesiones
\(\displaystyle \begin{array}{rcl} & & (10,20,30,40,50,...) \\ & & (1,0,1,0,1,0,1,0,...) \end{array} \)

no pertenecen a \(\omega ^{\left[ \mathbf{N}\right] }\). Notese que \( (s_{1},s_{2},...)\in \omega ^{\left[ \mathbf{N}\right] }\) si y solo si solo una cantidad finita de coordenadas de \((s_{1},s_{2},...)\) son no nulas (i.e. \(\{i:s_{i}\neq 0\}\) es finito)
Necesitaremos el siguente lema para probar una version del Teorema Fundamental de la Aritmetica la cual nos sera util para codificar elementos de \(\omega ^{\left[ \mathbf{N}\right] }\) con numeros naturales.

Lema 10 Si \(p,p_{1},...,p_{n}\) son numeros primos y \(p\) divide a \(p_{1}...p_{n}\), entonces \(p=p_{i}\), para algun \(i\).
Ahora la version del Teorema Fundamental de la Aritmetica.

Teorema 11 Para cada \(x\in \mathbf{N}\), hay una unica sucesion \((s_{1},s_{2},...)\in \omega ^{\left[ \mathbf{N}\right] }\) tal que
\(\displaystyle x=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}} \)
(Notese que \(\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}\) tiene sentido ya que es un producto que solo tiene una cantidad finita de factores no iguales a \(1\). )
Prueba: Primero probaremos la existencia por induccion en \(x\). Claramente \(1= \underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{0}\), con lo cual el caso \(x=1\) esta probado. Supongamos la existencia vale para cada \(y\) menor que \(x\), veremos que entonces vale para \(x\). Si \(x\) es primo, entonces \(x=pr(i_{0})\) para algun \(i_{0}\) por lo cual tenemos que \(x=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}\), tomando \(s_{i}=0\) si \(i\neq i_{0}\) y \(s_{i_{0}}=1\). Si \(x\) no es primo, entonces \(x=y_{1}.y_{2}\) con \(y_{1},y_{2}< x\). Por hipotesis inductiva tenemos que hay \((s_{1},s_{2},...),(t_{1},t_{2},...)\in \omega ^{\left[ \mathbf{N}\right] }\) tales que \(y_{1}=\underset{i=1}{\overset {\infty }{\Pi }}pr(i)^{s_{i}}\) y \(y_{2}=\underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{t_{i}}\). Tenemos entonces que \(x=\underset{i=1}{\overset{\infty }{ \Pi }}pr(i)^{s_{i}+t_{i}}\) lo cual concluye la prueba de la existencia.

Veamos ahora la unicidad. Suponganos que

\(\displaystyle \underset{i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}=\underset{i=1}{\overset{ \infty }{\Pi }}pr(i)^{t_{i}} \)

Si \(s_{i} >t_{i}\) entonces dividiendo ambos miembros por \(pr(i)^{t_{i}}\) obtenemos que \(pr(i)\) divide a un producto de primos todos distintos de el, lo cual es absurdo por el lema anterior. Analogamente llegamos a un absurdo si suponemos que \(t_{i} >s_{i}\), lo cual nos dice que \(s_{i}=t_{i}\), para cada \(i\in \mathbf{N}\) \(\Box\)
Notese que razonando con el lema anterior, podemos probar que si \(x=\underset {i=1}{\overset{\infty }{\Pi }}pr(i)^{s_{i}}\), entonces \(s_{i}=\max_{t}\left( pr(i)^{t}\text{ divide a }x\right) \), para cada \(i\in \mathbf{N}\). Definamos para \(x,i\in \mathbf{N}\),

\(\displaystyle (x)_{i}=\max_{t}\left( pr(i)^{t}\text{ divide a }x\right) . \)

Dada una sucesion \((s_{1},s_{2},...)\in \omega ^{\left[ \mathbf{N}\right] }\) definamos
\(\displaystyle \left\langle s_{1},s_{2},...\right\rangle =\underset{i=1}{\overset{\infty }{ \Pi }}pr(i)^{s_{i}} \)

Tenemos entonces el siguiente
Lema 12 Las funciones
\(\displaystyle \begin{array}{lll} \mathbf{N} & \rightarrow & \omega ^{\left[ \mathbf{N}\right] } \\ x & \rightarrow & ((x)_{1},(x)_{2},...) \end{array} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \begin{array}{rll} \omega ^{\left[ \mathbf{N}\right] } & \rightarrow & \mathbf{N} \\ (s_{1},s_{2},...) & \rightarrow & \left\langle s_{1},s_{2},...\right\rangle \end{array} \)
son biyecciones una inversa de la otra.
Prueba: Notese que para cada \(x\in \mathbf{N}\), tenemos que \(\left\langle (x)_{1},(x)_{2},...\right\rangle =x\). Ademas para cada \((s_{1},s_{2},...)\in \omega ^{\left[ \mathbf{N}\right] }\), tenemos que \(((\left\langle s_{1},s_{2},...\right\rangle )_{1},(\left\langle s_{1},s_{2},...\right\rangle )_{2},...)=(s_{1},s_{2},...)\). Es claro que lo anterior garantiza que los mapeos en cuestion son uno inversa del otro \(\Box\)

Para \(x\in \mathbf{N}\) definamos:

\(\displaystyle Lt(x)=\left\{ \begin{array}{lll} \max_{i}\;(x)_{i}\neq 0 & & \text{si }x\neq 1 \\ 0 & & \text{si }x=1 \end{array} \right. \)

Se tienen las siguientes propiedades basicas
Lema 13 Para cada \(x\in \mathbf{N}\):
\(Lt(x)=0\) sii \(x=1\)
\(x=\prod\nolimits_{i=1}^{Lt(x)}pr(i)^{(x)_{i}}\)
Cabe destacar entonces que la funcion \(\lambda ix[(x)_{i}]\) tiene dominio igual a \(\mathbf{N}^{2}\) y la funcion \(\lambda ix[Lt(x)]\) tiene dominio igual a \(\mathbf{N}\).

\section{Procedimientos efectivos}

Un concepto importante en ciencias de la computacion es el de procedimiento o metodo para realizar alguna tarea determinada. Nos interesan los procedimientos que estan definidos en forma precisa e inambigua, es decir aquellos en los cuales en cada etapa a seguir, la tarea a realizar esta objetivamente descripta.

Tambien podemos encontrar en procedimientos rigurosamente definidos la propiedad de no terminacion. Es decir puede suceder que para ciertos datos de entrada, la ejecucion del procedimiento nunca llegue a producir un resultado o dato de salida sino que a medida que se vayan realizando las instrucciones o tareas, siempre el procedimiento direccione a realizar otra tarea especifica y asi sucesivamente.

Cabe destacar que los procedimientos tambien deben ser repetibles, en el sentido de que si realizamos un procedimiento dos veces con el mismo dato de entrada, entonces ya sea en cada una de estas realizaciones el procedimiento no termina o en las dos termina y da como resultado el mismo dato de salida.

Una caracteristica de los procedimientos que surgen en la tarea cientifica es que hay un conjunto de datos de entrada, es decir, el conjunto de objetos a partir de los cuales puede comenzar a realizarse el procedimiento. Cabe destacar que para ciertos elementos de dicho conjunto puede pasar que el proceimiento no termine partiendo de ellos. Tambien en los procedimientos que surgen en la tarea cientifica tenemos un conjunto de datos de salida, es decir el conjunto de todos los datos que el procedimiento dara como salida al terminar partiendo de los distintos datos de entrada.

Otro aspecto muy importante a considerar es que un procedimiento puede tener pasos a seguir los cuales sean realizables solo en un sentido puramente teorico. Por ejemplo, un procedimiento puede tener una instruccion como la que se muestra a continuacion:

- si el polinomio \(ax^{5}+bx^{4}+421\) tiene una raiz racional, entonces realizar la tarea descripta en A, en caso contrario realizar la tarea descripta en B
(\(a,b\) son datos calculados previamente). Como puede notarse mas alla de este aspecto teorico de la instruccion, su descripcion es clara y objetiva, pero en principio no es claro que se pueda ejecutar dicha instruccion en un sentido efectivo a los fines de seguir realizando las siguientes instrucciones.

Un procedimiento sera llamado efectivo cuando cada paso del mismo sea efectivamente realizable.

\subsection{Funciones \(\Sigma \)-efectivamente computables}

Trabajaremos con procedimientos efectivos en los cuales el conjunto de datos de entrada es \(\omega ^{n}\times \Sigma ^{\ast m}\) para algunos \(n,m\geq 0\) y el conjunto de datos de salida esta contenido en \(\omega ^{k}\times \Sigma ^{\ast l}\) para algunos \(k,l\geq 0\). Tambien supondremos que los elementos de \(\omega \) que intervienen en los datos de entrada y de salida estaran representados en notacion decimal.

Una funcion \(\Sigma \)-mixta, \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \), sera llamada \(\Sigma \)-efectivamente computable si hay un procedimiento efectivo \(\mathbb{P}\) con las siguientes caracteristicas:

- El conjunto de datos de entrada de \(\mathbb{P}\) es \(\omega ^{n}\times \Sigma ^{\ast m}\)
- El conjunto de datos de salida esta contenido en \(\omega \).
- Si \((\vec{x},\vec{\alpha})\in D_{f}\) y corremos \(\mathbb{P}\) desde \( (\vec{x},\vec{\alpha})\), entonces \(\mathbb{P}\) termina y da como dato de salida \(f(\vec{x},\vec{\alpha})\).
- Si \((\vec{x},\vec{\alpha})\in (\omega ^{n}\times \Sigma ^{\ast m})-D_{f}\), entonces \(\mathbb{P}\) no termina partiendo de \((\vec{x},\vec{ \alpha})\)
En forma analoga se define cuando una funcion \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\) es \(\Sigma \) -efectivamente computable. En ambos casos diremos que la funcion \(f\) es computada por \(\mathbb{P}\).

Quisas el procedimiento mas famoso de la matematica es aquel que se ense\~{n} a en los colegios para sumar dos numeros naturales expresados en notacion decimal. Es decir que la funcion \(\lambda xy\left[ x+y\right] \) es \(\Sigma \) -efectivamente computable, cualquiera sea el alfabeto \(\Sigma \). Tambien las funciones \(\lambda xy\left[ x.y\right] ,\lambda xy\left[ x^{y}\right] \) son \( \Sigma \)-efectivamente computables via los procedimientos clasicos ense\~{n} ados en la escuela primaria. Veamos algunos ejemplos mas

Ejemplos: Consideremos \(\Sigma =\{\%,\& \}\).

(a) La funcion \(C_{3}^{1,2}\) es \(\Sigma \)-efectivamente computable ya que el siguiente procedimiento \(\mathbb{P}\) con conjunto de datos de entrada \( \omega \times \Sigma ^{\ast 2}\) la computa:

- Independientemente de quien sea el dato de entrada \((x_{1},\alpha _{1},\alpha _{2})\), terminar y dar como salida el numero \(3\)

(b) La funcion \(p_{3}^{2,3}\) es \(\Sigma \)-efectivamente computable ya que el siguiente procedimiento la computa:

- Dado el dato de entrada \((x_{1},x_{2},\alpha _{1},\alpha _{2},\alpha _{3})\) , terminar y dar como salida la palabra \(\alpha _{1}\)

(c) \(Pred\) es \(\Sigma \)-efectivamente computable. El siguiente procedimiento (con conjunto de datos de entrada igual a \(\omega \)) computa a \(Pred\):

Dado como dato de entrada un elemento \(x\in \omega \), realizar lo siguiente:

Etapa 1

Si \(x=0\), entonces ir a Etapa 3, en caso contrario ir a Etapa 2.

Etapa 2

Si \(x\neq 0\), entonces detenerse y dar como salida el valor \(x-1\).

Etapa 3

Si \(x=0\), entonces ir a Etapa 1.

(d) Si \(< \) es el orden total estricto sobre \(\Sigma \) dado por \(\& < \%\), entonces ya que \(s^{< }:\Sigma ^{\ast }\rightarrow \Sigma ^{\ast }\) es definida por

\(\displaystyle \begin{array}{rcl} s^{< }(\varepsilon ) & =& \& \\ s^{< }(\alpha \& ) & =& \alpha \% \\ s^{< }(\alpha \%) & =& s^{< }(\alpha )\& \end{array} \)

tenemos que \(s^{< }\) es \(\Sigma \)-efectivamente computable. Por ejemplo el siguiente procedimiento la computa. Tal como en los lenguajes de programacion, usaremos variables y asignaciones para dise\~{n}ar el procedimiento.
Etapa 1: Hacer las siguientes asignaciones

\(\displaystyle \begin{array}{rcl} A & \leftarrow & \alpha \\ B & \leftarrow & \varepsilon \\ F & \leftarrow & \& \end{array} \)

e ir a Etapa 2.
Etapa 2: Si \(A\) comiensa con \(\& \), entonces hacer las siguientes asignaciones

\(\displaystyle \begin{array}{rcl} A & \leftarrow & \text{resultado de remover el 1er simbolo de }A \\ B & \leftarrow & B\& \\ F & \leftarrow & B\% \end{array} \)

e ir a la Etapa 2. En caso contrario ir a la Etapa 3.
Etapa 3: Si \(A\) comiensa con \(\%\), entonces hacer las siguientes asignaciones

\(\displaystyle \begin{array}{rcl} A & \leftarrow & \text{resultado de remover el 1er simbolo de }A \\ B & \leftarrow & B\% \\ F & \leftarrow & F\% \end{array} \)

e ir a la Etapa 2. En caso contrario ir a la Etapa 4.
Etapa 4: Si \(A\) es \(\varepsilon \) entonces dar como salida \(F\)

(e) Usando que \(s^{< }\) es \(\Sigma \)-efectivamente computable podemos ver que \(\ast ^{< }:\omega \rightarrow \Sigma ^{\ast }\) tambien lo es ya que \(\ast ^{< }\) es definida con las recursiones

\(\displaystyle \begin{array}{rcl} \ast ^{< }(0) & =& \varepsilon \\ \ast ^{< }(x+1) & =& s^{< }(\ast ^{< }(x)) \end{array} \)

Dejamos como ejercico para el lector dise\~{n}ar procedimientos efectivos que computen las funciones:

- \(\lambda xy[x\) divide a \(y]\)

- \(\lambda x[pr(x)]\)

. \(\lambda ix[(x)_{i}]\)

\subsection{Conjuntos \(\Sigma \)-efectivamente enumerables}

Un conjunto \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) sera llamado \(\Sigma \)-efectivamente enumerable cuando sea vacio o haya un procedimiento efectivo \(\mathbb{P}\) con las siguientes caracteristicas:

- El conjunto de datos de entrada de \(\mathbb{P}\) es \(\omega \) y \( \mathbb{P}\) termina para cada dato de entrada \(x\in \omega \)
- El conjunto de datos de salida de \(\mathbb{P}\) es \(S\).
En tal caso diremos que el procedimiento \(\mathbb{P}\) enumera a \(S\) . Dicho de otra forma \(\mathbb{P}\) debe ser un procedimiento efectivo que para los datos de entrada \(0,1,2,3,...\), termine y produzca datos de salida \( e_{0},e_{1},e_{2},e_{3},...\) tales que \(S=\{e_{0},e_{1},e_{2},...\}\).

Ejemplos: (a) El conjunto \(S=\{x\in \omega :x\) es par\(\}\) es \( \Sigma \)-efctivamente enumerable, cualesquiera sea \(\Sigma \). El siguiente procedimiento enumera a \(S\):

- Calcular \(2x\), darlo como dato de salida y terminar.

(b) Un procedimiento que enumera \(\omega \times \omega \) es el siguiente:

Etapa 1

Si \(x=0\), dar como salida el par \((0,0)\) y terminar. Si \(x\neq 0\), calcular \( x_{1}=(x)_{1}\) y \(x_{2}=(x)_{2}\).

Etapa 2

Dar como dato de salida el par \((x_{1},x_{2})\) y terminar

Como puede notarse el procedimiento es efectivo y si tomamos un par cualquiera \((a,b)\in \omega \times \omega \), el procedimiento lo dara como dato de salida para la entrada \(x=2^{a}3^{b}\).

(c) Veamos que \(\omega ^{2}\times \Sigma ^{\ast 3}\) es \(\Sigma \) -efectivamente enumerable cualquiera sea el alfabeto \(\Sigma \). Sea \(< \) un orden total estricto para el alfabeto \(\Sigma \). Utilisando el orden \(< \) podemos dise\~{n}ar el siguiente procedimiento para enumerar \(\omega ^{2}\times \Sigma ^{\ast 3}\):

Etapa 1

Si \(x=0\), dar como salida \((0,0,\varepsilon ,\varepsilon ,\varepsilon )\) y terminar. Si \(x\neq 0\), calcular

\(x_{1}=(x)_{1}\)

\(x_{2}=(x)_{2}\)

\(\alpha _{1}=\ast ^{< }((x)_{3})\)

\(\alpha _{2}=\ast ^{< }((x)_{4})\)

\(\alpha _{3}=\ast ^{< }((x)_{5})\)

Etapa 2

Dar como dato de salida la 5-upla \((x_{1},x_{2},\alpha _{1},\alpha _{2},\alpha _{3})\).

Lema 14 Sean \(S_{1},S_{2}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) conjuntos \( \Sigma \)-efectivamente enumerables. Entonces \(S_{1}\cup S_{2}\) y \(S_{1}\cap S_{2}\) son \(\Sigma \)-efectivamente enumerables.
Prueba: El caso en el que alguno de los conjuntos es vacio es trivial. Supongamos que ambos conjuntos son no vacios y sean \(\mathbb{P}_{1}\) y \(\mathbb{P}_{2}\) procedimientos que enumeran a \(S_{1}\) y \(S_{2}\). El siguiente procedimiento enumera al conjunto \(S_{1}\cup S_{2}\):

- Si \(x\) es par realizar \(\mathbb{P}_{1}\) partiendo de \(x/2\) y dar el elemento de \(S_{1}\) obtenido como salida. Si \(x\) es impar realizar \(\mathbb{P }_{2}\) partiendo de \((x-1)/2\) y dar el elemento de \(S_{2}\) obtenido como salida.
Veamos ahora que \(S_{1}\cap S_{2}\) es \(\Sigma \)-efectivamente enumerable. Si \(S_{1}\cap S_{2}=\varnothing \) entonces no hay nada que probar. Supongamos entonces que \(S_{1}\cap S_{2}\) en no vacio. Sea \(z_{0}\) un elemento fijo de \( S_{1}\cap S_{2}.\) Sea \(\mathbb{P}\) un procedimiento efectivo el cual enumere a \(\omega \times \omega \) (ver el ejemplo de mas arriba). Un procedimiento que enumera a \(S_{1}\cap S_{2}\) es el siguiente

Etapa 1

Realizar \(\mathbb{P}\) con dato de entrada \(x\), para obtener un par \((x_{1},x_{2})\in \omega \times \omega \).

Etapa 2

Realizar \(\mathbb{P}_{1}\) con dato de entrada \(x_{1}\) para obtener un elemento \(z_{1}\in S_{1}\)

Etapa 3

Realizar \(\mathbb{P}_{2}\) con dato de entrada \(x_{2}\) para obtener un elemento \(z_{2}\in S_{2}\)

Etapa 4

Si \(z_{1}=z_{2}\), entonces dar como dato de salida \(z_{1}.\) En caso contrario dar como dato de salida \(z_{0}\). \(\Box\)
