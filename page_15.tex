\subsection{Funciones \(\Sigma \)-Turing computables}

Para poder computar funciones mixtas con una maquina de Turing necesitaremos un simbolo para representar numeros sobre la cinta. Llamaremos a este simbolo unit y lo denotaremos con \(\shortmid \). Mas formalmente una maquina de Turing con unit es una 8-upla \(M=\left( Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right) \) tal que \(\left( Q,\Sigma ,\Gamma ,\delta ,q_{0},B,F\right) \) es una maquina de Turing y \(\shortmid \) es un simbolo distingido perteneciente a \(\Gamma -(\{B\}\cup \Sigma )\).

Una maquina de Turing \(M\) sera llamada deterministica cuando se de que \(\left\vert \delta (p,\sigma )\right\vert \leq 1\), cualesquiera sean \( p\in Q\) y \(\sigma \in \Gamma \).

Diremos que una funcion \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \Sigma ^{\ast }\) es \(\Sigma \)-Turing computable si existe una maquina de Turing deterministica con unit, \(M=\left( Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right) \) tal que:

(1) Si \((\vec{x},\vec{\alpha})\in D_{f}\), entonces hay un \(p\in Q\) tal que
\(\displaystyle \left\lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right\rfloor \overset{\ast }{\vdash }\left\lfloor pBf( \vec{x},\vec{\alpha})\right\rfloor \)

y \(\left\lfloor pBf(\vec{x},\vec{\alpha})\right\rfloor \nvdash d\), para cada \(d\in Des\)
(2) Si \((\vec{x},\vec{\alpha})\in \omega ^{n}\times \Sigma ^{\ast m}-D_{f}\), entonces \(M\) no se detiene partiendo de
\(\displaystyle \left\lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right\rfloor . \)

En forma similar, una funcion \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow \omega \), es llamada \(\Sigma \)- Turing computable si existe una maquina de Turing deterministica con unit, \( M=\left( Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right) \), tal que:

(1) Si \((\vec{x},\vec{\alpha})\in D_{f}\), entonces hay un \(p\in Q\) tal que
\(\displaystyle \left\lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right\rfloor \overset{\ast }{\vdash }\left\lfloor pB\shortmid ^{f(\vec{x},\vec{\alpha})}\right\rfloor \)

y \(\left\lfloor pB\shortmid ^{f(\vec{x},\vec{\alpha})}\right\rfloor \nvdash d \), para cada \(d\in Des\)
(2) Si \((\vec{x},\vec{\alpha})\in \omega ^{n}\times \Sigma ^{\ast m}-D_{f}\), entonces \(M\) no se detiene partiendo de
\(\displaystyle \left\lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{m}\right\rfloor \)

Cuando \(M\) y \(f\) cumplan los items (1) y (2) de la definicion anterior, diremos que la funcion \(f\) es computada por \(M\).




\textbf{Teorema 83} Supongamos \(f:S\subseteq \omega ^{n}\times \Sigma ^{\ast }{}^{m}\rightarrow O \) es \(\Sigma \)-Turing computable. Entonces \(f\) es \(\Sigma \)-recursiva.
Prueba: Supongamos \(O=\Sigma ^{\ast }\) y sea \(M=\left( Q,\Sigma ,\Gamma ,\delta ,q_{0},B,\shortmid ,F\right) \) una maquina de Turing deterministica con unit la cual compute a \(f\). Sea \(< \) un orden total estricto sobre \(\Gamma \cup Q\) . Sea \(P:\mathbf{N}\times \omega ^{n}\times \Sigma ^{\ast m}\rightarrow \omega \) dado por \(P(x,\vec{x},\vec{\alpha})=1\) sii

\((\exists q\in Q)\;\left\lfloor q_{0}B\shortmid ^{x_{1}}...B\shortmid ^{x_{n}}B\alpha _{1}...B\alpha _{m}\right\rfloor \overset{(x)_{1}}{\vdash } \left\lfloor qB\ast ^{< }((x)_{2})\right\rfloor \wedge \)
\(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \wedge (\forall d\in Des)_{\left\vert d\right\vert \leq \left\vert \ast ^{< }((x)_{2})\right\vert +2}\;\left\lfloor qB\ast ^{< }((x)_{2})\right\rfloor \nvdash d\)
Es facil ver que \(P\) es \((\Gamma \cup Q)\)-p.r. por lo que \(P\) es \( \Sigma \)-p.r. ya que es \(\Sigma \)-mixto. Notese que

\(\displaystyle f=\lambda \vec{x}\vec{\alpha}\left[ \left( \min_{x}P(x,\vec{x},\vec{\alpha} )\right) _{2}\right] \text{,} \)

lo cual nos dice que \(f\) es \(\Sigma \)-recursiva. \(\Box\)
A continuacion nos proponemos probar que el paradigma de las maquinas de Turing es completo. El siguiente lema es clave ya que nos muestra como pueden simularse en forma muy natural, los programas de \(\mathcal{S}^{\Sigma }\) con maquinas de Turing deterministicas




\textbf{Lema 84} Sea \(\mathcal{P}\in \mathrm{Pro}^{\Sigma }\) y sea \(k\) tal que las variables que ocurren en \(\mathcal{P}\) estan todas en la lista \(\mathrm{N}1,..., \mathrm{N}\bar{k},\mathrm{P}1,...,\mathrm{P}\bar{k}.\) Para cada \(a\in \Sigma \cup \{\shortmid \}\), sea \(\tilde{a}\) un nuevo simbolo. Sea \(\Gamma =\Sigma \cup \{B,\shortmid \}\cup \{\tilde{a}:a\in \Sigma \cup \{\shortmid \}\}\). Entonces hay una maquina de Turing deterministica con unit \(M=\left( Q,\Gamma ,\Sigma ,\delta ,q_{0},B,\shortmid ,\{q_{f}\}\right) \) la cual satisface
(1) \(\delta (q_{f},\sigma )=\varnothing \), para cada \(\sigma \in \Gamma \).
(2) Cualesquiera sean \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\), el programa \(\mathcal{P}\) se detiene partiendo del estado
\(\displaystyle \left( (x_{1},...,x_{k},0,...),(\alpha _{1},...,\alpha _{k},\varepsilon ,...)\right) \)

sii \(M\) se detiene partiendo de la descripcion instantanea
\(\displaystyle \left\lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{k}}B\alpha _{1}B...B\alpha _{k}B\right\rfloor \)
(3) Si \(x_{1},...,x_{k}\in \omega \) y \(\alpha _{1},...,\alpha _{k}\in \Sigma ^{\ast }\) son tales que \(\mathcal{P}\) se detiene partiendo del estado
\(\displaystyle \left( (x_{1},...,x_{k},0,...),(\alpha _{1},...,\alpha _{k},\varepsilon ,...)\right) \)

y llega al estado
\(\displaystyle \left( (y_{1},...,y_{k},0,...),(\beta _{1},...,\beta _{k},\varepsilon ,...)\right) \)

entonces
\(\displaystyle \left\lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{k}}B\alpha _{1}B...B\alpha _{k}B\right\rfloor \overset{\ast }{\vdash }\left\lfloor q_{f}B\shortmid ^{y_{1}}B...B\shortmid ^{y_{k}}B\beta _{1}B...B\beta _{k}B\right\rfloor \)
Prueba: Dado un estado \(((x_{1},...,x_{k},0,...),(\alpha _{1},...,\alpha _{k},\varepsilon ,...))\) lo representaremos en la cinta de la siguiente manera

\(\displaystyle B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k}BBBB.... \)

A continuacion describiremos una serie de maquinas las cuales simularan, via la representacion anterior, las distintas clases de instrucciones que pueden ocurrir en \(\mathcal{P}\). Todas las maquinas definidas tendran a \(\shortmid \) como unit y a \(B\) como blanco, tendran a \(\Sigma \) como su alfabeto terminal y su alfabeto mayor sera \(\Gamma =\Sigma \cup \{B,\shortmid \}\cup \{\tilde{a }:a\in \Sigma \cup \{\shortmid \}\}\). Ademas tendran uno o dos estados finales con la propiedad de que si \(q\) es un estado final, entonces \(\delta (q,\sigma )=\varnothing \), para cada \(\sigma \in \Gamma \). Esta propiedad es importante ya que nos permitira concatenar pares de dichas maquinas identificando algun estado final de la primera con el inicial de la segunda.
Para \(1\leq i\leq k\), sea \(M_{i}^{+}\) una maquina tal que

\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}B\shortmid ^{x_{i}+1}B\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Es claro que la maquina \(M_{i}^{+}\) simula la instruccion \(\mathrm{N}\bar{ \imath}\leftarrow \mathrm{N}\bar{\imath}+1\).
Para \(1\leq i\leq k\), sea \(M_{i}^{\dot{-}}\) una maquina tal que

\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}B\shortmid ^{x_{i}\dot{-}1}B\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Para \(1\leq i\leq k\) y \(a\in \Sigma \), sea \(M_{i}^{a}\) una maquina tal que
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}B\alpha _{i}aB\alpha _{i+1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Para \(1\leq i\leq k\), sea \(M_{i}^{\curvearrowright }\) una maquina tal que
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}B^{\curvearrowright }\alpha _{i}B\alpha _{i+1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Para \(j=1,...,k\), y \(a\in \Sigma \), sea \(IF_{j}^{a}\) una maquina con dos estados finales \(q_{si}\) y \(q_{no}\) tal que si \(\alpha _{j}\) comienza con \(a\) , entonces
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{si} \end{array} \)

y en caso contrario
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{no} \end{array} \)

Analogamente para \(j=1,...,k\), sea \(IF_{j}\) una maquina tal que si \( x_{j}\neq 0\), entonces
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{si} \end{array} \)

y si \(x_{j}=0\), entonces
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{no} \end{array} \)

Para \(1\leq i,j\leq k\), sea \(M_{i\leftarrow j}^{\ast }\) una maquina tal que
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}B\alpha _{j}B\alpha _{i+1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Para \(1\leq i,j\leq k\), sea \(M_{i\leftarrow j}^{\#}\) una maquina tal que
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}B\shortmid ^{x_{j}}B\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Para \(1\leq i\leq k\), sea \(M_{i\leftarrow 0}\) una maquina tal que
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{i-1}}BB\shortmid ^{x_{i+1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Para \(1\leq i\leq k\), sea \(M_{i\leftarrow \varepsilon }\) una maquina tal que
\(\displaystyle \begin{array}{lcl} B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{k} & \overset{\ast }{\vdash } & B\shortmid ^{x_{1}}...B\shortmid ^{x_{k}}B\alpha _{1}...B\alpha _{i-1}BB\alpha _{i+1}...B\alpha _{k} \\ \uparrow & & \uparrow \\ q_{0} & & q_{f} \end{array} \)

Sea
\(\displaystyle M_{\mathrm{SKIP}}=\left( \{q_{0},q_{f}\},\Gamma ,\Sigma ,\delta ,q_{0},B,\shortmid ,\{q_{f}\}\right) , \)

con \(\delta (q_{0},B)=\{(q_{f},B,K)\}\) y \(\delta =\varnothing \) en cualquier otro caso.
Finalmente sea

\(\displaystyle M_{\mathrm{GOTO}}=\left( \{q_{0},q_{si},q_{no}\},\Gamma ,\Sigma ,\delta ,q_{0},B,\shortmid ,\{q_{si},q_{no}\}\right) , \)

con \(\delta (q_{0},B)=\{(q_{si},B,K)\}\) y \(\delta =\varnothing \) en cualquier otro caso.
Para poder hacer concretamente las maquinas recien descriptas deberemos dise \~{n}ar antes algunas maquinas auxiliares. Para cada \(j\geq 1\), sea \(D_{j}\) la maquina descripta en la Figura 1. Notese que

\(\displaystyle \begin{array}{lcr} \alpha B\beta _{1}B\beta _{2}B...B\beta _{j}B\gamma & \overset{\ast }{\vdash } & \alpha B\beta _{1}B\beta _{2}B...B\beta _{j}B\gamma \\ \ \ \uparrow & & \uparrow \ \ \\ \ \ q_{0} & & q_{f}\ \ \end{array} \)

siempre que \(\alpha ,\gamma \in \Gamma ^{\ast }\), \(\beta _{1},...,\beta _{j}\in (\Gamma -\{B\})^{\ast }\). Analogamente tenemos definidas las maquinas \(I_{j}.\)
Para \(j\geq 1\), sea \(TD_{j}\) una maquina con un solo estado final \(q_{f}\) y tal que

\(\displaystyle \begin{array}{ccc} \alpha B\gamma & \overset{\ast }{\vdash } & \alpha BB\gamma \\ \uparrow & & \uparrow \ \ \\ q_{0} & & q_{f}\ \ \end{array} \)

cada vez que \(\alpha ,\gamma \in \Gamma ^{\ast }\) y \(\gamma \) tiene exactamente \(j\) ocurrencias de \(B\). Es decir la maquina \(TD_{j}\) corre un espacio a la derecha todo el bloque \(\gamma \) y agrega un blanco en el espacio que se genera a la izquierda de dicho bloque. Por ejemplo, para el caso de \(\Sigma =\{\& \}\) podemos tomar \(TD_{3}\) igual a la maquina de la Figura 3.
Analogamente, para \(j\geq 1\), sea \(TI_{j}\) una maquina tal que

\(\displaystyle \begin{array}{ccc} \alpha B\sigma \gamma & \overset{\ast }{\vdash } & \alpha B\gamma \\ \uparrow \ & & \uparrow \\ q_{0}\ \ & & q_{f} \end{array} \)

cada vez que \(\alpha \in \Gamma ^{\ast }\), \(\sigma \in \Gamma \) y \(\gamma \) tiene exactamente \(j\) ocurrencias de \(B\). Es decir la maquina \(TI_{j}\) corre un espacio a la izquierda todo el bloque \(\gamma \) (por lo cual en el lugar de \(\sigma \) queda el primer simbolo de \(\gamma \)).
Teniendo las maquinas auxiliares antes definidas podemos combinarlas para obtener las maquinas simuladoras de instrucciones. Por ejemplo \(M_{i}^{a}\) puede ser la maquina descripta en la Figura 4. En la Figura 2 tenemos una posible forma de dise\~{n}ar la maquina \(IF_{i}^{a}\). En la Figura 7 tenemos una posible forma de dise\~{n}ar la maquina \(M_{i\leftarrow j}^{\ast }\) para el caso \(\Sigma =\{a,b\}\) y \(i< j\).

Supongamos ahora que \(\mathcal{P}=I_{1}...I_{n}\). Para cada \(i=1,...,n\), definiremos una maquina \(M_{i}\) que simulara la instruccion \(I_{i}\). Luego uniremos adecuadamente estas maquinas para formar la maquina que simulara a \( \mathcal{P}\)

- Si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{j}+1\) tomaremos \(M_{i}=M_{j}^{+}\)
- Si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{j}\dot{-} 1 \) tomaremos \(M_{i}=M_{j}^{\dot{-}}\)
- Si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow 0\) tomaremos \( M_{i}=M_{j\leftarrow 0}\).
- Si \(Bas(I_{i})=\mathrm{N}\bar{j}\leftarrow \mathrm{N}\bar{m}\) tomaremos \(M_{i}=M_{j\leftarrow m}^{\#}\).
- Si \(Bas(I_{i})=\mathrm{IF}\;\mathrm{N}\bar{j}\not=0\) \(\mathrm{GOTO} \;\mathrm{L}\bar{m}\) tomaremos \(M_{i}=IF_{j}.\)
- Si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \mathrm{P}\bar{j}.a\) tomaremos \(M_{i}=M_{j}^{a}\).
- Si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \ ^{\curvearrowright } \mathrm{P}\bar{j}\) tomaremos \(M_{i}=M_{j}^{\curvearrowright }\).
- Si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \varepsilon \) tomaremos \( M_{i}=M_{j\leftarrow \varepsilon }\).
- Si \(Bas(I_{i})=\mathrm{P}\bar{j}\leftarrow \mathrm{P}\bar{m}\) tomaremos \(M_{i}=M_{j\leftarrow m}^{\ast }\).
- Si \(Bas(I_{i})=\mathrm{IF}\;\mathrm{P}\bar{j}\;\mathrm{BEGINS}\;a\; \mathrm{GOTO}\;\mathrm{L}\bar{m}\) tomaremos \(M_{i}=IF_{j}^{a}\).
- Si \(Bas(I_{i})=\mathrm{SKIP}\) tomaremos \(M_{i}=M_{\mathrm{SKIP}}\).
- Si \(Bas(I_{i})=\mathrm{GOTO}\;\mathrm{L}\bar{m}\) tomaremos \( M_{i}=M_{\mathrm{GOTO}}\).
Ya que la maquina \(M_{i}\) puede tener uno o dos estados finales, la representaremos como se muestra en la Figura 5, entendiendo que en el caso en que \(M_{i}\) tiene un solo estado final, este esta representado por el circulo de abajo a la izquierda y en el caso en que \(M_{i}\) tiene dos estados finales, el estado final representado con lineas punteadas corresponde al estado \(q_{si}\) y el otro al estado \(q_{no}\).

Para armar la maquina que simulara a \(\mathcal{P}\) hacemos lo siguiente. Primero unimos las maquinas \(M_{1},...,M_{n}\) como lo muestra la Figura 6. Luego para cada \(i\) tal que \(Bas(I_{i})\) es de la forma \(\alpha \mathrm{GOTO} \;\mathrm{L}\bar{m}\), ligamos con una flecha de la forma

\(\displaystyle \underrightarrow{\;\;\;\;\;\;B,B,K\;\;\;\;\;\;} \)

el estado final \(q_{si}\) de la \(M_{i}\) con el estado inicial de la \(M_{h}\), donde \(h\) es tal que \(I_{h}\) es la primer instruccion que tiene label \( \mathrm{L}\bar{m}\).
Es intuitivamente claro que la maquina asi obtenida cumple con lo requerido aunque una prueba formal de esto puede resultar extremadamente tediosa. \(\Box\)
Usando el lema anterior podemos probar que el paradigma computacional de Turing es completo.




\par \textbf{Teorema 85} Si \(f:D_{f}\subseteq \omega ^{n}\times \Sigma ^{\ast m}\rightarrow O\) es \( \Sigma \)-recursiva, entonces \(f\) es \(\Sigma \)-Turing computable.
Prueba: Supongamos \(O=\Sigma ^{\ast }.\) Ya que \(f\) es \(\Sigma \)-computable, existe \( \mathcal{P}\in \mathrm{Pro}^{\Sigma }\) el cual computa \(f\). Note que podemos suponer que \(\mathcal{P}\) tiene la propiedad de que cuando \(\mathcal{P}\) termina, en el estado alcansado las variables numericas tienen todas el valor \(0\) y las alfabeticas distintas de \(\mathrm{P}1\) todas el valor \( \varepsilon \). Sea \(M\) la maquina de Turing con unit dada por el lema anterior, donde elejimos el numero \(k\) con la propiedad adicional de ser mayor que \(n\) y \(m\). Sea \(M_{1}\) una maquina tal que para cada \((\vec{x}, \vec{\alpha})\in \omega ^{n}\times \Sigma ^{\ast m}\),

\(\displaystyle \left\lfloor q_{0}B\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B\alpha _{1}B...B\alpha _{n}B\right\rfloor \overset{\ast }{\vdash }\left\lfloor qB\shortmid ^{x_{1}}B...B\shortmid ^{x_{n}}B^{k-n}B\alpha _{1}B...B\alpha _{m}B\right\rfloor \)

donde \(q_{0}\) es el estado inicial de \(M_{1}\) y \(q\) es un estado tal que \( \delta (q,\sigma )=\varnothing \), para cada \(\sigma .\) Sea \(M_{2}\) una maquina tal que para cada \(\alpha \in \Sigma ^{\ast }\),
\(\displaystyle \left\lfloor q_{0}B^{k+1}\alpha \right\rfloor \overset{\ast }{\vdash } \left\lfloor qB\alpha \right\rfloor \)

donde \(q_{0}\) es el estado inicial de \(M_{2}\) y \(q\) es un estado tal que \( \delta (q,\sigma )=\varnothing \), para cada \(\sigma \). Note que la concatenacion de \(M_{1}\), \(M\) y \(M_{2}\) (en ese orden) produce una maquina de Turing la cual computa \(f\). \(\Box\)





\textbf{Teorema 86} Si \(L\subseteq \Sigma ^{\ast }\) es \(\Sigma \)-r.e., entonces \(L=L(M)=H(M)\) para alguna maquina de Turing deterministica \(M.\)
Prueba: Por el Teorema 71 hay una funcion \(f:L\rightarrow \omega \), la cual es \(\Sigma \)-recursiva\(.\) Sea \(\mathcal{P}\) un programa el cual compute a \(f\). Sea \(M\) la maquina de Turing deterministica dada en el lema anterior. Sea \(M_{1}\) una maquina de Turing deterministica tal que para todo \(\alpha \in \Sigma ^{\ast }\),

\(\displaystyle \left\lfloor q_{0}B\alpha \right\rfloor \overset{\ast }{\vdash }\left\lfloor qB^{k+1}\alpha \right\rfloor \)

donde \(q_{0}\) es el estado inicial de \(M\) y \(q\) es un estado tal que \(\delta (q,\sigma )=\varnothing \), para cada \(\sigma \). Note que la concatenacion de \( M_{1}\) con \(M\) (en ese orden) produce una maquina de Turing deterministica \( M_{2}\) tal que \(H(M_{2})=L(M_{2})=L\). \(\Box\)
