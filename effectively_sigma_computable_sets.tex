\section{Conjuntos $\Sigma$-efectivamente computables}

  \textbf{\underline{Lemma 15:}} Si \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\) es \(\Sigma \) -efectivamente computable entonces \(S\) es \(\Sigma \)-efectivamente enumerable.

  \textbf{\underline{Proof:}} Supongamos \(S\neq \varnothing \). Sea \((\vec{z},\gamma )\in S\), fijo. Sea \( \mathbb{P}\) un procedimiento efectivo que compute a \(\chi _{S}\). Ya vimos en el ejemplo anterior que \(\omega ^{2}\times \Sigma ^{\ast 3}\) es \(\Sigma \) -efectivamente enumerable. En forma similar se puede ver que \(\omega ^{n}\times \Sigma ^{\ast m}\) lo es. Sea \(\mathbb{P}_{1}\) un procedimiento efectivo que enumere a \(\omega ^{n}\times \Sigma ^{\ast m}\). Entonces el siguiente procedimiento enumera a \(S\):

Etapa 1

Realizar \(\mathbb{P}_{1}\) con \(x\) de entrada para obtener \((\vec{x} ,\vec{\alpha})\in \omega ^{n}\times \Sigma ^{\ast m}.\)

Etapa 2

Realizar \(\mathbb{P}\) con \((\vec{x},\vec{\alpha})\) de entrada para obtener el valor Booleano \(e\) de salida\(.\)

Etapa 3

Si \(e=1\) dar como dato de salida \((\vec{x},\vec{\alpha}).\) Si \(e=0\) dar como dato de salida \((\vec{z},\gamma )\). \(\Box\)


  \textbf{\underline{Theorem 16:}} Sea \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\). Son equivalentes
  (a) \(S\) es \(\Sigma \)-efectivamente computable
  (b) \(S\) y \((\omega ^{n}\times \Sigma ^{\ast m})-S\) son \(\Sigma \) -efectivamente enumerables

  \textbf{\underline{Proof:}} (a)\(\Rightarrow \)(b). Por el lema anterior tenemos que \(S\) es \(\Sigma \) -efectivamente enumerable. Notese ademas que, dado que \(S\) es \(\Sigma \) -efectivamente computable, \((\omega ^{n}\times \Sigma ^{\ast m})-S\) tambien lo es (por que?). Es decir que aplicando nuevamente el lema anterior tenemos que \((\omega ^{n}\times \Sigma ^{\ast m})-S\) es \(\Sigma \)-efectivamente enumerable.

(b)\(\Rightarrow \)(a). Sea \(\mathbb{P}_{1}\) un procedimiento efectivo que enumere a \(S\) y sea \(\mathbb{P}_{2}\) un procedimiento efectivo que enumere a \((\omega ^{n}\times \Sigma ^{\ast m})-S\). Es facil ver que el siguiente procedimiento computa el predicado \(\chi _{S}\):

Etapa 1

Darle a la variable \(T\) el valor \(0\).

Etapa 2

Realizar \(\mathbb{P}_{1}\) con el valor de \(T\) como entrada para obtener de salida la upla \((\vec{y},\vec{\beta})\).

Etapa 3

Realizar \(\mathbb{P}_{2}\) con el valor de \(T\) como entrada para obtener de salida la upla \((\vec{z},\vec{\gamma})\).

Etapa 4

Si \((\vec{y},\vec{\beta})=(\vec{x},\vec{\alpha})\), entonces detenerse y dar como dato de salida el valor \(1\). Si \((\vec{z},\vec{\gamma} )=(\vec{x},\vec{\alpha})\), entonces detenerse y dar como dato de salida el valor \(0.\) Si no suceden ninguna de las dos posibilidades antes mensionadas, aumentar en \(1\) el valor de la variable \(T\) y dirijirse a la Etapa 2. \(\Box\)

  \textbf{\underline{Theorem 17:}} Dado \(S\subseteq \omega ^{n}\times \Sigma ^{\ast m}\), son equivalentes
(1) \(S\) es \(\Sigma \)-efectivamente enumerable
(2) \(S=\varnothing \) o \(S=I_{F}\), para alguna \(F:\omega \rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal que cada \(F_{i}\) es \(\Sigma \) -efectivamente computable.
(3) \(S=I_{F}\), para alguna \(F:D_{F}\subseteq \omega ^{k}\times \Sigma ^{\ast l}\rightarrow \omega ^{n}\times \Sigma ^{\ast m}\) tal que cada \(F_{i}\) es \(\Sigma \)-efectivamente computable.
(4) \(S=D_{f}\), para alguna funcion \(f\) la cual es \(\Sigma \) -efectivamente computable.

  \textbf{\underline{Proof:}} (1)\(\Rightarrow \)(2) y (2)\(\Rightarrow \)(1) son muy naturales y son dejadas al lector. (2)\(\Rightarrow \)(3) es trivial.

(3)\(\Rightarrow \)(4). Para \(i=1,...,n+m\), sea \(\mathbb{P}_{i}\) un procedimiento el cual computa a \(F_{i}\) y sea \(\mathbb{P}\) un procedimiento el cual enumere a \(\omega \times \omega ^{k}\times \Sigma ^{\ast l}.\) El siguiente procedimiento computa la funcion \(f:I_{F}\rightarrow \{1\}\):

Etapa 1

Darle a la variable \(T\) el valor 0.

Etapa 2

Hacer correr \(\mathbb{P}\) con dato de entrada \(T\) y obtener \( (t,z_{1},...,z_{k},\gamma _{1},...,\gamma _{l})\) como dato de salida.

Etapa 3

Para cada \(i=1,...,n+m\), hacer correr \(\mathbb{P}_{i}\) durante \(t\) pasos, con dato de entrada \((z_{1},...,z_{k},\gamma _{1},...,\gamma _{l}).\) Si cada procedimiento \(\mathbb{P}_{i}\) al cabo de los \(t\) pasos termino y dio como resultado el valor \(o_{i}\), entonces comparar \((\vec{x},\vec{\alpha} )\) con \((o_{1},...,o_{n+m})\) y en caso de que sean iguales detenerse y dar como dato de salida el valor \(1\). En el caso en que no son iguales, aumentar en \(1\) el valor de la variable \(T\) y dirijirse a la Etapa 2. Si algun procedimiento \(\mathbb{P}_{i}\) al cabo de los \(t\) pasos no termino, entonces aumentar en \(1\) el valor de la variable \(T\) y dirijirse a la Etapa 2.

(4)\(\Rightarrow \)(1). Supongamos \(S\neq \varnothing .\) Sea \((\vec{z},\vec{ \gamma})\) un elemento fijo de \(S.\) Sea \(\mathbb{P}\) un procedimiento el cual compute a \(f\). Sea \(\mathbb{P}_{1}\) un procedimiento el cual enumere a \( \omega \times \omega ^{n}\times \Sigma ^{\ast m}.\) Dejamos al lector el dise \~{n}o de un procedimiento efectivo el cual enumere \(D_{f}\). \(\Box\)
